{"pages":[],"posts":[{"title":"CentOS 7 部署 NFS Server","text":"创建 NFS 服务端后才能够正常使用 NFS 文件系统。本文介绍了在 CentOS 7 系统中安装 NFS 服务器的过程，并给出了 NFS 客户端的相关配置 一、概述 NFS（Network File System）：通过网络让不同的机器/操作系统共享文件，一般用来共享静态数据 二、部署 NFS 服务端1234567891011121314151617181920212223242526272829# 1. 关闭防火墙$ systemctl stop firewalld &amp;&amp; systemctl disable firewalld# 2. 安装 nfs-utils 和 rpcbind（NFS 客户端也安装）$ yum install -y nfs-utils rpcbind# 3. 创建用于共享数据的文件夹$ mkdir /data/nfs$ chown -R nfsnobody:nfsnobody /data/nfs # TODO 用户影响？# 4. 配置 NFS Server：指定共享文件夹目录以及能够使用共享文件夹的网段$ vi /etc/exports# `NFS共享目录 NFS客户端地址1(参数1,参数2,...) 客户端地址2(参数1,参数2,...)`# /data/nfs 10.17.102.0/24(rw,async,no_root_squash)/data/nfs *(rw,async,no_root_squash) # 对所有 IP 都有效# 5. 启动 NFS Server$ systemctl restart rpcbind$ systemctl enable nfs &amp;&amp; systemctl restart nfs# 6. 测试$ showmount -e 10.17.102.29 # 查看是否有可用的 NFS 地址Export list for 10.17.102.29:/data/nfs *$ nfsstat -s # 查看服务端 NFS 信息Server rpc stats:calls badcalls badclnt badauth xdrcall2822050 0 0 0 0... 1. 服务端配置 常用选项： ro：客户端挂载后，其权限为只读，默认选项 rw：读写权限 sync：同步将数据写入到内存与硬盘中 async：异步，优先将数据保存到内存，然后再写入硬盘 secure：要求请求源的端口小于 1024 用户映射： root_squash：当 NFS 客户端使用 root 用户访问时，映射到 NFS 服务器的匿名用户 no_root_squash：当 NFS 客户端使用 root 用户访问时，映射到 NFS 服务器的 root 用户 all_squash：全部用户都映射为服务器端的匿名用户 anonuid=UID：将客户端登录用户映射为此处指定的用户 uid anongid=GID：将客户端登录用户映射为此处指定的用户 gid 三、部署 NFS 客户端12345678910$ yum install -y nfs-utils rpcbind$ mkdir -p /data/nfs-data# -t nfs：使用nfs协议# -o：挂载选项## nolock：不阻塞## vers=4：NFS版本号为4$ mount -t nfs -o nolock,vers=4 10.17.102.29:/data/nfs /data/nfs-data$ df -h # 查看挂载$ umount /data/nfs-data # 卸载挂载$ nfsstat -c # 查看客户端 NFS 信息","link":"/Linux/centos7-nfs-server.html"},{"title":"Windows OpenSSH 密钥管理","text":"适用于 Windows Server 2019、Windows 10、Windows Server 2022 文章完成了对 Windows 上的 OpenSSH 使用基于密钥的身份验证所需的配置。完成此项后，用户可以从具有私钥的任何客户端连接到 sshd 主机 1. 常见身份认证 Windows 环境中的大多数身份验证都是使用用户名/密码对完成的，这非常适用于共享公共域的系统。跨域工作时（例如在本地和云托管的系统之间），很容易受到暴力攻击入侵 相比之下，Linux 环境通常使用公钥/私钥对来驱动身份验证，这不要求使用可推测的密码。OpenSSH 提供了工具来帮助支持此用途，具体如下： ssh-keygen：用于生成安全的密钥 ssh-agent 和 ssh-add：用于安全地存储私钥 scp 和 sftp：在首次使用服务器时安全地复制公钥文件 2. 密钥对概述 密钥对指的是由特定的身份验证协议使用的公钥和私钥文件 SSH 公钥身份验证使用不对称加密算法来生成两个密钥文件：一个为“私钥”文件，一个为“公钥”文件 私钥：等效于密码，在所有情况下都应当保护它们。如果有人获取了你的私钥，则他们可以像你一样登录到你有权登录的任何 SSH 服务器 公钥：放置在 SSH 服务器上，并且可以共享，不会危害私钥的安全 将密钥身份验证用于 SSH 服务器时，SSH 服务器和客户端会依据私钥来比较所提供的用户名的公钥。 如果无法依据客户端私钥验证服务器端公钥，则身份验证失败 可以通过密钥对实现多重身份验证，方法是在生成密钥对时输入密码。在身份验证期间，会提示用户输入密码，将使用该密码以及 SSH 客户端上的私钥来对用户进行身份验证 3. 主机密钥生成 首先需要安装 OpenSSH 服务器，参考 OpenSSH 入门 公钥具有特定的 ACL 要求，在 Windows 上，这些要求等同于仅允许管理员和 System 进行访问。首次使用 sshd 时，将自动生成主机的密钥对 默认情况下，sshd 服务设置为手动启动。若要在每次重新启动服务器时启动它，请从服务器上的 PowerShell 中运行以下命令： 12345# Set the sshd service to be started automatically$ Get-Service -Name sshd | Set-Service -StartupType Automatic# Now start the sshd service$ Start-Service sshd 由于没有与 sshd 服务关联的用户，因此主机密钥存储在 C:\\ProgramData\\ssh 下 4. 用户密钥生成 若要使用基于密钥的身份验证，首先需要为客户端生成公钥/私钥对 ssh-keygen.exe 用于生成密钥文件，并且可以指定算法 DSA、RSA、ECDSA 或 Ed25519。如果未指定算法，则使用 RSA。建议使用强算法和密钥长度 以下为使用 Ed25519 算法生成密钥文件的流程： 12345678910111213141516171819202122232425262728$ ssh-keygen -t ed25519Generating public/private ed25519 key pair.Enter file in which to save the key (C:\\Users\\Test/.ssh/id_ed25519):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\\Users\\Test/.ssh/id_ed25519.Your public key has been saved in C:\\Users\\Test/.ssh/id_ed25519.pub.The key fingerprint is:SHA256:GBoxfWOjq/ss1GziqAOeqlQgYcYKSBV1x8hxinSRTUQ test@DESKTOP-GQT4EP9The key's randomart image is:+--[ED25519 256]--+|=+.o=+.=@E ||=o .o=+Oo ||+. ...= o ||o . o.o || ..o..S ||. . o = ||o..+ + ||oo. +. ||*o .+o |+----[SHA256]-----+$ cd C:\\Users\\Test\\.ssh$ dirMode LastWriteTime Length Name---- ------------- ------ -----a---- 2021/11/18 18:50 411 id_ed25519 # 私钥-a---- 2021/11/18 18:50 103 id_ed25519.pub # 公钥-a---- 2021/11/17 15:44 92 known_hosts 私钥文件等效于密码，应当采用与保护密码相同的方式来保护它。为了实现此目的，请使用 ssh-agent 来将私钥安全地存储在与你的 Windows 登录关联的 Windows 安全上下文中 为执行该操作，请以管理员身份启动 ssh-agen 服务并使用 ssh-add 来存储私钥： 123456789101112# By default the ssh-agent service is disabled. Allow it to be manually started for the next step to work.# Make sure you're running as an Administrator.$ Get-Service ssh-agent | Set-Service -StartupType Manual# Start the service$ Start-Service ssh-agent# This should return a status of Running$ Get-Service ssh-agent# Now load your key files into ssh-agent$ ssh-add ~\\.ssh\\id_ed25519 完成这些步骤后，每当从此客户端进行身份验证需要使用私钥时，ssh-agent 都会自动检索本地私钥，并将其传递到你的 SSH 客户端 强烈建议你将私钥备份到一个安全位置，将其添加到 ssh-agent，然后将其从本地系统中删除。如果使用了强算法（例如此示例中的 Ed25519），则无法从代理中检索私钥 如果你失去了对私钥的访问权限，则必须在你与之交互的所有系统上创建一个新的密钥对并更新公钥 5. 部署公钥 若要使用上面创建的用户密钥，需要将公钥 ~\\.ssh\\id_ed25519.pub 的内容放置在服务器上的一个文本文件中，其名称和位置取决于用户帐户是本地管理员组的成员还是标准用户帐户 (1) 标准用户 公钥 ~\\.ssh\\id_ed25519.pub 的内容需放置在服务器上的一个名为 authorized_keys 的文本文件中，该文件位于 C:\\Users\\username\\.ssh\\ OpenSSH 客户端包括了 scp 来帮助实现此目的，这是一个安全的文件传输实用工具。以下示例将公钥复制到服务器 12345# Make sure that the .ssh directory exists in your server's user account home folder$ ssh username@domain1@contoso.com mkdir C:\\Users\\username\\.ssh\\# Use scp to copy the public key file generated previously on your client to the authorized_keys file on your server$ scp C:\\Users\\Test\\.ssh\\id_ed25519.pub user1@domain1@contoso.com:C:\\Users\\username\\.ssh\\authorized_keys (2) 管理用户 公钥 ~\\.ssh\\id_ed25519.pub 的内容需放置在服务器上的一个名为 administrators_authorized_keys 的文本文件中，该文件位于 \\ 此文件上的 ACL 需要配置为仅允许访问管理员和系统。以下示例将公钥复制到服务器并配置 ACL 12345678# Make sure that the .ssh directory exists in your server's user account home folder$ ssh user1@domain1@contoso.com mkdir C:\\ProgramData\\ssh\\# Use scp to copy the public key file generated previously on your client to the authorized_keys file on your server$ scp C:\\Users\\Test\\.ssh\\id_ed25519.pub user1@domain1@contoso.com:C:\\ProgramData\\ssh\\administrators_authorized_keys# Appropriately ACL the authorized_keys file on your server$ ssh --% user1@domain1@contoso.com icacls.exe &quot;C:\\ProgramData\\ssh\\administrators_authorized_keys&quot; /inheritance:r /grant &quot;Administrators:F&quot; /grant &quot;SYSTEM:F&quot; 此示例演示了创建 administrators_authorized_keys file 的步骤。如果多次运行，则每次都会覆盖此文件。若要为多个管理用户添加公钥，需将此文件附加到每个公钥 参考 OpenSSH 入门 适用于 Windows 的 OpenSSH 密钥管理 | Microsoft Docs NIST 文档 IR 7966","link":"/Win/win-ssh-keygen.html"},{"title":"GitHub + Hexo 搭建个人网站详细教程","text":"文章介绍了使用 GitHub + Hexo（icarus 主题）搭建个人网站的详细教程，包括环境准备、项目初始化、项目运行、构建、部署等具体操作，给出了 icarus 主题的各项配置案例，并且对项目源码进行了个性化修改 1. 环境准备 Node.js（&gt;=10.13）：http://nodejs.org/ Git：http://git-scm.com/ 123456789101112131415161718192021$ npm install hexo-cli -g$ hexo -vhexo-cli: 4.3.0os: win32 10.0.17763node: 16.13.0v8: 9.4.146.19-node.13uv: 1.42.0zlib: 1.2.11brotli: 1.0.9ares: 1.17.2modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1l+quiccldr: 39.0icu: 69.1tz: 2021aunicode: 13.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV 2. 初始化项目 官网：https://ppoffice.github.io/hexo-theme-icarus/ 12345678$ hexo init blog$ cd blog$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b 4.3.0 --depth 1$ hexo config theme icarus$ hexo server$ npm install --save hexo-deployer-git # 部署时用到$ npm install 若报错 err: Error: Cannot find module 'babel-plugin-inferno'，可删除 node_modules/ 和 package-lock.json，再执行 npm install 3. Hexo 常用命令12345678910# 启动$ hexo s [-i 192.168.1.1] [-p 5000]# 清除缓存$ hexo clean# 新建博文$ hexo n &quot;title&quot;# 生成结果$ hexo g# 部署$ hexo d 4. 配置文件设置_config.page.yml 1widgets: null _config.post.yml 123456789101112131415widgets: - position: left type: toc index: false collapsed: false depth: 3 - position: left type: adsense client_id: 'ca-pub-3689070375600295' slot_id: '8031940281'sidebar: left: sticky: true _config.icarus.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232version: 4.0.0variant: cyberpunklogo: /img/logo.svghead: favicon: /img/logo.svg # https://developer.mozilla.org/en-US/docs/Web/Manifest manifest: name: LB477 short_name: LB start_url: theme_color: background_color: display: standalone icons: - src: '' sizes: '' type: # https://hexo.io/docs/helpers.html#open-graph open_graph: title: type: blog url: image: site_name: author: description: twitter_card: twitter_id: twitter_site: google_plus: fb_admins: fb_app_id: # https://developers.google.com/search/docs/guides/intro-structured-data structured_data: title: description: url: author: publisher: publisher_logo: image: meta: - '' rss: navbar: menu: Home: / Categories: /categories Tags: /tags Archives: /archives #About: /about links: Download on GitHub: icon: fab fa-github url: 'https://github.com/liubin477'footer: links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Noncommercial: icon: fab fa-creative-commons-nc url: 'https://creativecommons.org/licenses/by-nc/4.0/'article: highlight: # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: rainbow clipboard: true fold: unfolded readtime: false licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Noncommercial: icon: fab fa-creative-commons-nc url: 'https://creativecommons.org/licenses/by-nc/4.0/'# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Search/search: type: insight# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/comment: type: valine app_id: *** app_key: *** placeholder: &quot;（づ￣3￣）づ╭❤～&quot; avatar: wavatar avatar_force: false meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] page_size: 10 lang: zh-CN visitor: false highlight: true record_ip: true server_urls: emoji_cdn: emoji_maps: enable_qq: false required_fields: []# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Donation/donates: - type: alipay qrcode: '/img/alipay.png' - type: wechat qrcode: '/img/wechat.png'# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/share: type: addtoanysidebar: left: sticky: false right: sticky: false# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - position: left type: profile author: LB author_title: location: Mars avatar: /img/head.jpg avatar_rounded: true gravatar: follow_link: 'https://github.com/liubin477' social_links: Github: icon: fab fa-github url: 'https://github.com/liubin477' CNBlogs: icon: fas fa-edit url: 'https://www.cnblogs.com/lb477' - position: left type: archives - position: right type: categories - position: right type: tags - position: right type: recent_posts - position: left type: adsense client_id: 'ca-pub-3689070375600295' slot_id: '8031940281'# -# position: left# type: links# links:# Hexo: 'https://hexo.io'# Bulma: 'https://bulma.io'# # Google FeedBurner email subscription widget configurations# -# position: left# type: subscribe_email# # Hint text under the email input# description: # # Feedburner ID# feedburner_id: ''# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/plugins: # Enable page startup animations animejs: true # Show the &quot;back to top&quot; button back_to_top: true # https://tongji.baidu.com baidu_analytics: tracking_id: *** # https://www.bing.com/toolbox/webmaster/ bing_webmaster: tracking_id: *** # http://busuanzi.ibruce.info busuanzi: true # CNZZ statistics # https://www.umeng.com/web cnzz: id: *** web_id: *** # https://www.osano.com/cookieconsent/ cookie_consent: # The compliance type. Can be &quot;info&quot;, &quot;opt-in&quot;, or &quot;opt-out&quot; type: info # Theme of the popup. Can be &quot;block&quot;, &quot;edgeless&quot;, or &quot;classic&quot; theme: edgeless # Whether the popup should stay static regardless of the page scrolls static: false # Where on the screen the consent popup should display position: bottom-left # URL to your site's cookie policy policyLink: 'https://www.cookiesandyou.com/' gallery: true # https://analytics.google.com google_analytics: tracking_id: # https://www.hotjar.com/ hotjar: site_id: # https://katex.org/ katex: false # https://www.mathjax.org/ mathjax: false # http://outdatedbrowser.com/ outdated_browser: false # Show a progress bar at top of the page on page loading progressbar: true # https://statcounter.com/ statcounter: project: security: # https://business.twitter.com/en/help/campaign-measurement-and-analytics/conversion-tracking-for-websites.html twitter_conversion_tracking: pixel_id: # https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus-user-guide-cdn-providers/providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome _config.yml 12345678910111213# ...url: https://lb477.xyzpermalink: :title.htmlpermalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinksdeploy: type: git repo: git@github.com:liubin477/liubin477.github.io.git branch: master 5. 不显示文件更新时间themes/icarus/layout/common/article.jsx 1234{/* Last Update Date */}{/*page.updated &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{ __html: _p('article.updated_at', `&lt;time dateTime=&quot;${date_xml(page.updated)}&quot; title=&quot;${new Date(page.updated).toLocaleString()}&quot;&gt;${date(page.updated)}&lt;/time&gt;`)}}&gt;&lt;/span&gt;*/} 6. 设置文章绝对发布时间themes/icarus/source/js/main.js 12345// if (typeof moment === 'function') {// $('.article-meta time').each(function() {// $(this).text(moment($(this).attr('datetime')).fromNow());// });// } 7. 页面整体宽度调整themes/icarus/include/style/responsive.styl 12345678910111213+widescreen() .is-1-column .container, .is-2-column .container max-width: $desktop width: $desktop+fullhd() .is-2-column .container max-width: $widescreen width: $widescreen .is-1-column .container max-width: $desktop width: $desktop themes/icarus/layout/common/widgets.jsx 12case 2: return 'is-4-tablet is-4-desktop is-3-widescreen'; themes/icarus/layout/layout.jsx 12'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2,'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 8. 文章图片居中themes/icarus/source/js/main.js 1$(this).wrap('&lt;a class=&quot;gallery-item&quot; style=&quot;display:block;text-align:center;&quot; href=&quot;' + $(this).attr('src') + '&quot;&gt;&lt;/a&gt;'); 9. 部署到 GitHub 在 GitHub 上新建仓库 &lt;username&gt;.github.io 设置 SSH 密钥：Windows OpenSSH 密钥管理 10. 解决主题文件夹无法提交到 Github1234567891011121314$ git rm --cache themes/icarus$ rm -rf themes/icarus/.git$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: themes/icarusUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) themes/","link":"/Other/hexo-icarus-config.html"},{"title":"使用 PicGo 和 Github 自建免费图床","text":"写博客会经常与图片打交道，因此图床是一个不得不考虑的话题。网上有不少三方的，但是用起来总不如自己构建的放心，本文介绍了使用 PicGo 和 GitHub 构建免费好用且稳定的自建图床 一、概述 PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具 PicGo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 特色功能 支持拖拽图片上传 支持快捷键上传剪贴板里第一张图片 Windows 和 MacOS 支持右键图片文件通过菜单上传 (v2.1.0+) 上传图片后自动复制链接到剪贴板 支持自定义复制到剪贴板的链接格式 支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS）| control+shift+p（Windows\\Linux) 支持插件系统，已有插件支持 Gitee、青云等第三方图床 更多第三方插件以及使用了 PicGo 底层的应用可以在 Awesome-PicGo 找到 支持通过发送 HTTP 请求调用 PicGo 上传（v2.2.0+) 下载网址：https://github.com/Molunerfinn/PicGo 二、Github 配置1. 创建 Github 仓库 创建一个 public 的 Github 仓库，仓库名为 blog-images。过程略 2. 创建访问令牌 直接访问 https://github.com/settings/tokens，点击 Generate new token 按照下图配置创建即可 三、PicGo 配置 点击左侧的图床设置，找到 Github 图床，配置如下： 可选：在 PicGo 设置中开启上传前重命名 四、Typora 配置","link":"/Other/picgo-github-images.html"},{"title":"PotPlayer 个性化配置","text":"本文介绍了 PotPlayer 播放器的安装、播放选项配置、音频/视频解码器/渲染器配置等 一、简介 PotPlayer 是 KMPlayer 原作者姜勇囍进入新公司 Daum（韩国科技巨头 Kakao Corp 并购）之后推出的，继承了 KMPlayer 所有的优点，拥有异常强大的内置音视频解码器，可以支持几乎全部音乐、视频文件格式的播放。采用 VC++ 进行了全面重构，并且原生支持 64 位操作系统；凭借硬件加速、流畅优秀的全高清视频播放效果、强大的选项、滤镜、外挂式管理、DXVA 等硬件解码，以及非常丰富且强大的设置选项，被誉为 Win 平台上最优秀的免费影音全能格式播放器 硬件加速：支持 DXVA、CUDA、QuickSync 等，以最少的资源制造最华丽的表现 3D/VR：支持大量不同型号的 3D 眼镜，连接电视或电脑立即享受 3D 视觉盛宴。支持 Side by Side、Top and Bottom、Page Flipping 等输出 字幕：支持文字字幕 SMI、SRT、Vobsub(DVD)、蓝光 SUP 字幕等多种字幕资源。支持 ASS/SSA 动画以及 SMI ruby tag 解码器：无需再麻烦地安装各种全能编解码器。支持 OpenCodec，用户自定义添加需要的编解码器 高级功能： 多个文件一次性读取，流畅播放 双声卡时，可自定义输出 各时间段截图方便快速切换到不同场景 提供特定场景添加并管理书签、章节功能 支持 Direct3D9 Ex Flip Mode、Overlay 功能 支持其它硬件设备播放（DVD、TV、HDTV） 二、安装 链接：https://pan.baidu.com/s/1VCfBLBsNULmBvuPWq1ADbA 提取码：vlyx PotPlayer 工具包中包括 PotPlayer 播放器安装包、LAV Filters（分离/解码器）、madVR（视频渲染器）、xy-VSFilter（通用字幕插件）、xy-SubFilter（madVR 专用字幕插件）等 1. 安装 PotPlayer 播放器 安装路径：D:\\App\\PotPlayer 2. 安装 LAV Filters 分离解码器 安装路径：D:\\App\\PM Players 注册：以管理员权限运行依次运行三个文件夹中的 install*.bat 文件 三、配置 想要得到好的画质效果，就必须要对 PotPlayer 播放器的默认方案进行更改。其中 TAB 键可以调出 OSD 菜单 EVR 渲染器是 PotPlayer 播放器自带的渲染器，一般国内的暴风影音、迅雷播放器都是用的之中很菜的渲染器，播放的画质很一般，这里会将其替换为 LAV Filters 方案 1. 播放配置 这里主要对进度条进行配置 2. 滤镜配置 关闭默认滤镜配置 载入并添加下载好的 LAV Filters 分离解码器 源滤镜/分离器全部换成 LAV Splitter Source（无法切换保持原状即可，下同） 视频解码器全部换成 LAV Video Decoder 音频解码器全部换成 LAV Audio Decoder 3. 视频配置 madVR 视频渲染器配置 madVR 是 Win 平台最强大的视频渲染器，媲美顶级蓝光机 色彩空间/属性配置 4. 声音配置 音频渲染器配置 WASAPI 音频渲染器具有程序独占，抗干扰，延迟低的优点 关闭规格化，避免 Potplayer 擅自改变音量 5. Decoder 配置 在属性中点击相应 Decoder 即可进入其配置界面 LAV Video Decoder 配置 软解，顾名思义就是 CPU 处理器解码；硬解是显卡解码 解码方案优先级推荐：CPU 软解 &gt; D3D11 = DXVA2(copy-back) = IntelQuickSnyc &gt; DXVA2(native) &gt; NVIDIA CUVID LAV Audio Decoder 配置 6. 其他 直播源导入：添加 -&gt; 添加文件 参考 https://www.bilibili.com/read/cv6470674/ https://github.com/imDazui/Tvlist-awesome-m3u-m3u8","link":"/Other/potplayer-config.html"},{"title":"Vue main.js 中 render 配置项详解","text":"[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 问题 在 Vue 脚手架构建的项目中，若在 main.js 中 new Vue 时使用 template 配置项，则浏览器控制台报错：[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 1234567import Vue from 'vue'import App from './App.vue'new Vue({ template: `&lt;App /&gt;`, components: { App }}).$mount('#app') 原因 main.js 中引入的是运行版本的 Vue，即 vue.runtime.esm.js，它没有模板编译器 vue.js 是完整版 Vue，包含核心功能（生命周期、事件处理、数据绑定等）和模板解析器，其中模板解析器占总文件的 1/3 vue.runtime.xxx.js 是运行版 Vue，只包含核心功能，没有模板解析器，不能解析 template 配置项，但提供了一个 render 函数用于渲染内容 在开发阶段，模板解析器可以帮我们解析模板。但代码打包发布后，就不再需要模板解析器了，也减小了打包后文件的体积 xxx.vue 组件中的模板通过 vue-template-compiler 工具解析 解决 1 使用包含模板编译器的 Vue 版本 1234567import Vue from 'vue/dist/vue'import App from './App.vue'new Vue({ template: `&lt;App /&gt;`, components: { App }}).$mount('#app') 解决 2（推荐） 将预编译模板放入 render 函数中 12345678import Vue from 'vue'new Vue({ render(createElement) { console.log(typeof createElement) // function return createElement('h1', 'HELLO') // h1是HTML内置元素，需要具体内容，因此传两个参数 }}).$mount('#app') 也可直接渲染组件 123456import Vue from 'vue'import App from './App.vue'new Vue({ render: h =&gt; h(App)}).$mount('#app') 其他 若通过 ES6 模块化语法引入第三方库，引入的具体文件在 package.json 的 module 属性配置","link":"/Vue/vue-render.html"},{"title":"Java 开发环境搭建以及 IDEA 2020.1 详细配置","text":"本文致力于搭建一个完备的 Java 开发环境，介绍了 Java 集成开发环境 IntelliJ IDEA 2020.1 的个性化配置，列出了常用的快捷键，同时也对 JDK、Maven、Git 做了简单的配置 一、IDEA 概述1. JetBrains 公司介绍 IDEA 是 JetBrains 公司的产品，公司旗下还有其它产品，比如： WebStorm：用于开发 JavaScript、HTML5、CSS3 等前端技术 PyCharm：用于开发 python PhpStorm：用于开发 PHP RubyMine：用于开发 Ruby/Rails AppCode：用于开发 Objective - C/Swift CLion：用于开发 C/C++ DataGrip：用于开发数据库和 SQL Rider： 用于开发 .NET GoLand： 用于开发 Go Android Studio：用于开发 android（google 基于 IDEA 社区版进行迭代） 2. IntelliJ IDEA 介绍 IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境。IDEA 在业界被公认为是最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的 IntelliJ IDEA 主要用于支持 Java、Scala、Groovy 等语言的开发工具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和 Web 应用的开发 优势： 强大的整合能力。比如：Git、Maven、Spring 等 提示功能的快速、便捷 提示功能的范围广 好用的快捷键和代码模板 精准搜索 下载地址：https://www.jetbrains.com/idea/download/#section=windows 官方使用文档：https://www.jetbrains.com/help/idea/getting-started.html 旗舰版（Ultimate）和社区版（Community）的区别：https://www.jetbrains.com/products/compare/?product=idea&amp;product=idea-ce 3. 下载安装 版本：2020.1.1 准备：内存 8G、CPU i5、SSD、JDK 安装激活：略 4. 调整 VM 配置 配置文件路径：IntelliJ IDEA 2020.1.1/bin/idea64.exe.vmoptions 32 位操作系统内存不会超过 4G：不建议调整 64 位操作系统中 8G 内存以下的机子：不建议调整 64 位操作系统中 8G 内存以上的机子：建议调整如下 123-Xms128m // 设置初始内存数，可提高Java程序的启动速度。16G内存的机器可设置为`-Xms512m`-Xmx750m // 设置最大内存数，可减少内存收集的频率，提高程序性能。16G内存的机器可设置为`-Xmx1500m`-XX:ReservedCodeCacheSize=240m // 保留代码占用的内存容量。16G内存的机器可设置为`-XX:ReservedCodeCacheSize=500m` 二、IDEA 设置 以下操作均在启动界面的 Configure -&gt; Settings 选项中进行 1. 滚轮修改字体大小 General -&gt; Change font size with Ctrl+Mouse Wheel(on) 2. 自动导包 Auto Import -&gt; Insert imports on paste(Ask) / Add unambiguous imports on the fly(on) / Optimize imports on the fly(on) 3. 显示方法之间的分割线 Editor/Appearance -&gt; Show method separators 4. 忽略大小写提示 默认首字母大写才提示 Code Completion -&gt; Match case(off) 5. Tab 页多行显示 打开文件很多时，多行显示而非隐藏 Editor Tabs -&gt; Show tabs in one row(off) 6. 代码字体 Font -&gt; Font(Courier New) / Size(16) / Line spacing(1.1) / Fallback font(Consolas) 7. 类头注释 File and Code Templates/Includes/File Header 1234/** * @author liubin * @since ${YEAR}-${MONTH}-${DAY} ${TIME} */ ${PACKAGE_NAME}：name of the package in which the new file is created ${USER}：current user system login name ${DATE}：current system date ${TIME}：current system time ${YEAR}：current year ${MONTH}：current month ${MONTH_NAME_SHORT}：first 3 letters of the current month name. Example: Jan, Feb, etc. ${MONTH_NAME_FULL}：full name of the current month. Example: January, February, etc. ${DAY}：current day of the month ${DAY_NAME_SHORT}：first 3 letters of the current day name. Example: Mon, Tue, etc. ${DAY_NAME_FULL}：full name of the current day. Example: Monday, Tuesday, etc. ${HOUR}：current hour ${MINUTE}：current minute ${PROJECT_NAME}：the name of the current project 8. 文件编码 File Encodings -&gt; Global Encoding(UTF-8) / Project Encoding(UTF-8) / Default encoding for properties files(UTF-8) / Transparent native-to-ascii conversion(on) 9. 关闭打开项目为最后关闭项目 System Settings -&gt; Reopen last project on startup(off) 10. 去除 IDEA 自带的 .iml/.idea 文件 File Types -&gt; Ignore files and folders(*.iml;*.idea;) 11. 不折叠一行的函数 Code Folding -&gt; One-line methods(off) 12. 注释格式 Java 注释优化：Code Style/Java -&gt; Code Generation/Line comment at first column(off) Html 注释优化：Code Style/HTML -&gt; Code Generation/Line comment at first column(off) / Block comment at first column(off) 13. 开启渲染 JavaDoc Appearance -&gt; Render documentation comments(on) 14. Debuger Debugger -&gt; Transport(Shared memory) 15. 关闭自动更新 Updates -&gt; Automatically check updates(off) 三、其他软件及配置1. JDK 安装版本：8u212 环境变量： JAVA_HOME CLASSPATH Path D:\\Develop\\Java\\jdk-8u212 .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; %JAVA_HOME%\\bin IDEA 配置：Configure -&gt; Structure for New Projects -&gt; Project SDK 2. Maven Maven 是 Apache 提供的一款自动化构建工具，用于自动化构建和依赖管理。开发团队基本不用花多少时间就能自动完成工程的基础构建配置，因为 Maven 使用了一个标准的目录结构和一个默认的构建生命周期 清理：表示在编译代码前将之前生成的内容删除 编译：将源代码编译为字节码 测试：运行单元测试用例程序 报告：测试程序的结果 打包：将 Java 项目打成 jar 包；将 Web 项目打成 war 包 安装：将 jar 或 war 生成到 Maven 仓库中 部署：将 jar 或 war 从 Maven 仓库中部署到 Web 服务器上运行 需联网：Maven 的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插件来完成。Maven 核心程序会到本地仓库中查找插件，如果本地仓库中没有就会从远程中央仓库下载，此时如果不能上网则无法执行 Maven 的具体功能 安装版本：3.6.3 环境变量配置： MAVEN_HOME Path D:\\Develop\\apache-maven-3.6.3 %MAVEN_HOME%\\bin 1$ mvn -v settings.xml： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!-- 不配置：https://blog.csdn.net/winterIsComing7/article/details/109014797 --&gt; &lt;!-- &lt;localRepository&gt;D:\\Develop\\repository&lt;/localRepository&gt; --&gt; &lt;pluginGroups&gt;&lt;/pluginGroups&gt; &lt;proxies&gt;&lt;/proxies&gt; &lt;servers&gt;&lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt;&lt;/profiles&gt;&lt;/settings&gt; IDEA 配置：Maven -&gt; Maven home directory / User settings file / Local repository 3. Git 下载地址：https://git-scm.com/download/win IDEA 配置：Git -&gt; Path to Git executable -&gt; git.exe 从 Github 上拉取项目： 方式一：VCS -&gt; Get From Version Control 方式二：File -&gt; New/Project from Version Control 四、插件 插件下载地址：https://plugins.jetbrains.com/plugin 必装： Lombok：Lombok 彩虹括号：Rainbow Brackets 代码小地图：CodeGlance Mybatis：MyBatisX 控制台日志美化：Grep Console 驼峰式命名和下划线命名交替变化：CamelCase 快速生成对象 set 方法：GenerateAllSetter 非必装： 快捷键提示：Key Promoter X 代码统计：Statistic Restful：RestfulToolkit Json 生成 Java：GsonFormat 代码时序图：SequenceDiagram 五、快捷键 Import Settings -&gt; keymap-shkstart.jar 常用快捷键： 快捷键 描述 alt + r 执行 alt + / 提示补全 ctrl + / 单行注释 ctrl + shift + / 多行注释 ctrl + alt + down 向下复制一行 ctrl + d 删除一行或选中行 alt + down 向下移动行 alt + up 向上移动行 shift + enter 向下开始新的一行 ctrl + shift +enter 向上开始新的一行 ctrl + 选中 或 ctrl + shift + t 查看源码 alt + enter 万能解错 / 生成返回值变量 alt + left 退回到前一个编辑的页面 alt + right 进入到下一个编辑的页面 F4 查看继承关系 ctrl + shift + F 格式化代码 ctrl + alt + / 提示方法参数类型 ctrl + c 复制代码 ctrl + z 撤销 ctrl + y 反撤销 ctrl + x 剪切 ctrl + v 粘贴 ctrl + s 保存 ctrl + a 全选 tab 选中数行，整体往后移动 shift + tab 选中数行，整体往前移动 ctrl + o 查看类的结构：类似于 eclipse 的 outline alt + shift + r 重构： 修改变量名与方法名 ctrl + shift + y 大写转小写 / 小写转大写 alt +shift + s 生成构造器 / get / set / toString F2 查看文档说明 alt + shift + c 收起所有的方法 alt + shift + x 打开所有方法 ctrl + shift + x 打开代码所在硬盘文件夹 alt + shift + z 生成 try-catch 等 alt + shift + f 局部变量抽取为成员变量 ctrl + f 当前文件查找 / 替换 ctrl + h 全局查找 shift + shift 查找文件 ctrl + shift + u 查看类的继承结构图 ctrl + alt + h 查看方法的多层重写结构 ctrl + alt + f 添加到收藏 alt + shift + m 抽取方法 ctrl + E 打开最近修改的文件 ctrl + w 关闭当前打开的代码栏 ctrl + shift + w 关闭打开的所有代码栏 ctrl + shift + q 快速搜索类中的错误 ctrl + shift + v 选择要粘贴的内容 ctrl + shift + h 查找方法在哪里被调用 六、其他1. 生成 Java Doc Tools -&gt; Generate JavaDoc Locale：zh_CN Other command line arguments：-encoding UTF-8 -charset UTF-8 2. 缓存和索引的清理 IntelliJ IDEA 首次加载项目的时候，都会创建索引。而创建索引的时间跟项目的文件多少成正比 IDEA 的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度。但是，在某些特殊条件下，IDEA 的缓存和索引文件也是会损坏的，比如：断电、蓝屏引起的强制关机，当重新打开 IDEA，很可能 IDEA 会报各种莫名其妙错误，甚至项目打不开 清除：File -&gt; Invalidate Caches / Restart -&gt; Invalidate and Restart 清除索引和缓存会使得 IDEA 的 LocalHistory 丢失。可以将项目加入版本控制，或备份 LocalHistory 目录","link":"/Java/idea-config.html"},{"title":"自定义 Windows 右键菜单","text":"本文介绍了如何自定义 Windows 右键菜单 右键菜单项储存在注册表 HKEY_CLASSES_ROOT 中，一般各种程序的右键菜单项都可以在此项下面找到 常用的注册表路径 桌面空白处：计算机\\HKEY_CLASSES_ROOT\\DesktopBackground\\Shell 图片：计算机\\HKEY_CLASSES_ROOT\\SystemFileAssociations\\image\\shell 文件夹：计算机\\HKEY_CLASSES_ROOT\\Directory\\shell 文件和文件夹：计算机\\HKEY_CLASSES_ROOT\\AllFilesystemObjects\\shell 文件夹空白处：计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 添加到右键菜单项 打开注册表编辑器：win + r，输入 regedit 进入想要自定义的注册表路径，右键新建项，输入名称 选中新建的项，在右侧默认处双击，写入右键菜单中显示的文本 选中新建的项，在右侧右击新建字符串值，命名为 icon，双击写入图标所在的绝对路径 右击新创建的项，新建一个子项，命名为 command 选中新建的 command，在右侧默认处双击，写入需要执行的命令 %1 表示当前右击文件的绝对路径 实例","link":"/Other/windows-right-menu.html"},{"title":"SpringSecurity 配置详解","text":"文章主要对 WebSecurityConfigurerAdapter 中的 configure(HttpSecurity http) 方法中的各项配置进行了详细介绍，灵活使用这些配置即可完成大部分认证授权操作 自定义登录配置类需要继承 WebSecurityConfigurerAdapter，并重写 configure(HttpSecurity http) 方法 1. 自定义登录页面、登录跳转static/login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; static/main.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录成功&lt;/body&gt;&lt;/html&gt; static/error.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录失败 &lt;a href= &quot;/login.html&quot;&gt;首页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; SecurityConfig.java（代码只供阅读参考） 12345678910111213141516171819202122232425262728293031public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { // 自定义登录界面 http.formLogin().loginPage(&quot;/login.html&quot;); // 只配置这个则所有的请求都能进，无需登录 // 授权 http.authorizeRequests() // 放行 .antMatchers(&quot;/login.html&quot;).permitAll() // 其他请求必须登录 .anyRequest().authenticated(); // 此时只有登录后才能访问其他界面（但此时不能执行默认的登录逻辑，因为没有配置登录接口以及csrf） // 需要和表单提交的接口一致（会执行默认的登录逻辑） http.formLogin().loginProcessingUrl(&quot;/login&quot;); // 需关闭csrf，表单才能正常发送请求 http.csrf().disable(); http.formLogin() // 登录成功后跳转的URL（只接受POST请求） .successForwardUrl(&quot;/toMain&quot;) // 登录失败后跳转的URL（只接受POST请求） .failureForwardUrl(&quot;/toError&quot;); http.authorizeRequests() // 需放行error.html（此时未登录） .antMatchers(&quot;/error.html&quot;).permitAll(); }} LoginController.java 12345678910111213@Controllerpublic class LoginController { @PostMapping(&quot;/toMain&quot;) public String toMain() { return &quot;redirect:main.html&quot;; } @PostMapping(&quot;/toError&quot;) public String toError() { return &quot;redirect:error.html&quot;; }} 2. 自定义表单提交的参数 默认的表单参数及请求方式在 UsernamePasswordAuthenticationFilter 中指定 SecurityConfig.java 123http.formLogin() .usernameParameter(&quot;username1&quot;) .passwordParameter(&quot;password1&quot;) 3. 自定义登录成功/失败处理器 主要面向前后端分离项目 上文 successForwardUrl() 和 failureForwardUrl() 内部逻辑都为 request.getRequestDispatcher(forwardUrl).forward(request, response); MyAuthenticationSuccessHandler.java 12345678910111213141516171819public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler { private String url; public MyAuthenticationSuccessHandler(String url) { this.url = url; } @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { System.out.println(authentication.getName()); // admin System.out.println(authentication.getCredentials()); // null System.out.println(authentication.getAuthorities()); // [ROLE_test, admin, normal] System.out.println(authentication.getPrincipal() instanceof User); // true System.out.println(authentication.getPrincipal()); // o.s.s.c.u.User@586034f: Username: admin; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_test,admin,normal System.out.println(authentication.getDetails()); // o.s.s.w.a.WebAuthenticationDetails@fffc7f0c: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: FCE0CA1D3A479BDBA513E558EB2EC024 response.sendRedirect(url); }} MyAuthenticationFailureHandler.java 12345678910111213public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler { private String url; public MyAuthenticationFailureHandler(String url) { this.url = url; } @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { response.sendRedirect(url); }} SecurityConfig.java 12345http.formLogin() //.successForwardUrl(&quot;/toMain&quot;) # 只能二选一 .successHandler(new MyAuthenticationSuccessHandler(&quot;/main.html&quot;)) //.failureForwardUrl(&quot;/toError&quot;) .failureHandler(new MyAuthenticationFailureHandler(&quot;/error.html&quot;)); 4. 访问控制 url 匹配 在配置类中，http.authorizeRequests() 可以根据 url 进行控制访问，也就是授权 通过公式 &lt;url匹配规则&gt;.&lt;权限控制方法&gt;，在所有匹配规则中取所有规则的交集，配置顺序也会影响之后授权效果（越是具体的应该放在前面，越是笼统的应该放到后面） anyRequest() 表示匹配所有的请求，一般用于全部请求都需要进行认证 注：只能配置在 antMatchers 之后，否则抛出异常 Can't configure antMatchers after anyRequest 1anyRequest().authenticated(); antMatcher() 方法定义为 public C antMatchers(String... antPatterns)，有不定参数，每个参数是一个 ant 表达式，用于匹配 URL 规则 ?：匹配一个字符 *：匹配 0 个或多个字符 **：匹配 0 个或多个目录 12.antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;).permitAll().antMatchers(&quot;/**/*.js&quot;).permitAll() regexMatchers() 与 antMatcher() 类似，但使用正则表达式进行匹配 1.regexMatchers( &quot;.+[.]js&quot;).permitAll() mvcMatchers() 适用于配置了 servletPath 的情况 其中 .servletPath() 是 mvcMatchers() 返回值特有的方法 12// 等同于`.antMatchers(&quot;/service-test/test&quot;).permitAll()`.mvcMatchers(&quot;/test&quot;).servletPath(&quot;/service-test&quot;).permitAll() 双参数 antMatcher() 和 regexMatchers() 都具有两个参数的方法，其中第一个参数为 HttpMethod，表示只有指定的请求方式才执行对应的权限设置 5. 内置访问控制方法permitAll() 表示所匹配的 URL 任何人都允许访问，无需登录 123public ExpressionInterceptUrlRegistry permitAll() { return access(&quot;permitAll&quot;);} authenticated() 表示所匹配的 URL 需要被认证才能访问 123public ExpressionInterceptUrlRegistry permitAll() { return access(&quot;permitAll&quot;);} anonymous() 表示可以匿名访问匹配的URL。和 permitAll() 效果类似，只是设置为 anonymous() 的 url 会执行在 filter 链中 123public ExpressionInterceptUrlRegistry anonymous() { return access(&quot;anonymous&quot;);} denyAll() 表示所匹配的 URL 不允许被访问 123public ExpressionInterceptUrlRegistry denyAll() { return access(&quot;denyAll&quot;);} rememberMe() 表示被“remember me”的用户才允许访问 123public ExpressionInterceptUrlRegistry rememberMe() { return access(&quot;rememberMe&quot;);} fullyAuthenticated() 表示用户登录后且不是被“remember me”的，才可以访问 123public ExpressionInterceptUrlRegistry fullyAuthenticated() { return access(&quot;fullyAuthenticated&quot;);} 6. 基于权限/角色的访问控制 这些方法一般都用于用户已经被认证后，判断用户是否具有访问特定资源的权限 用户的权限是在自定义登录逻辑中创建 UserDetails 对象时指定的 权限名严格区分大小写 hasAuthority() 判断用户是否具有特定的权限 1.antMatchers(&quot;/test&quot;).hasAuthority(&quot;admin&quot;) hasAnyAuthority() 如果用户具备给定权限中某一个，就允许访问 1.antMatchers(&quot;/test&quot;).hasAnyAuthority(&quot;admin&quot;, &quot;ADMIN&quot;) hasRole() 如果用户具备给定角色就允许访问 在给用户赋予角色时需要以 ROLE_ 开头 12// 这里不能再添加`ROLE_`前缀，否则会报错.antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;) hasAnyRole() 如果用户具备给定角色的任意一个，就允许被访问 1.antMatchers(&quot;/test&quot;).hasAnyRole(&quot;test&quot;, &quot;TEST&quot;) hasIpAddress() 如果请求来源是指定的 IP 就允许访问 底层是通过 request.getRemoteAddr() 获取 IP 其中 localhost 对应 0:0:0:0:0:0:0:1 1.antMatchers(&quot;/test&quot;).hasIpAddress(&quot;127.0.0.1&quot;) 7. 授权失败处理器 当登录的用户没有权限访问某一资源时，会执行该处理器中的逻辑 MyAccessDeniedHandler.java 123456789101112@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler { @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); PrintWriter out = response.getWriter(); out.write(&quot;{\\&quot;status\\&quot;:\\&quot;error\\&quot;,\\&quot;msg\\&quot;:\\&quot;权限不足！\\&quot;}&quot;); out.flush(); out.close(); }} SecurityConfig.java 12345@Autowiredprivate MyAccessDeniedHandler myAccessDeniedHandler;http.exceptionHandling() .accessDeniedHandler(myAccessDeniedHandler); 8. 基于表达式的访问控制 之前的登录/权限判断底层实现都是调用 access(...) https://docs.spring.io/spring-security/site/docs/5.3.12.RELEASE/reference/html5/#el-common-built-in 12.antMatchers(&quot;/test&quot;).access(&quot;permitAll&quot;).antMatchers(&quot;/test&quot;).access(&quot;hasAuthority('admin')&quot;) 自定义表达式 在 access() 中可通过 @&lt;bean_id&gt;.&lt;method&gt;(&lt;args&gt;) 形式调用表达式。若表达式返回值为 true，则允许访问 MyServiceImpl.java 12345678910111213@Componentpublic class MyServiceImpl { // 通过URI判断权限 public boolean hasPermission(HttpServletRequest request, Authentication authentication) { Object obj = authentication.getPrincipal(); if (obj instanceof UserDetails){ UserDetails userDetails = (UserDetails) obj; Collection&lt;? extends GrantedAuthority&gt; authorities = userDetails.getAuthorities(); return authorities.contains(new SimpleGrantedAuthority(request.getRequestURI())); } return false; }} SecurityConfig.java 1.anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;) 9. 基于注解的访问控制 SpringSecurity 中提供了一些访问控制的注解，这些注解默认是不可用的，需要通过 @EnableGlobalMethodSecurity 开启后使用 注解可以写到 Service 接口或方法上，也可以写到 Controller 或 Controller 的方法上。通常情况下都是写在 Controller 方法上，控制接口 URL 是否允许被访问 权限名严格区分大小写 @Secured 专门用于判断是否具有角色，参数要以 ROLE_ 开头 12// 在启动类或配置类添加注解@EnableGlobalMethodSecurity(securedEnabled = true) 12345@Secured(&quot;ROLE_test&quot;)@RequestMapping(&quot;/toMain&quot;)public String toMain(){ return &quot;redirect:/main.html&quot;;} @PreAuthorize / @PostAuthorize @PreAuthorize 表示访问方法或类在执行之前先判断权限，注解的参数和 access() 方法参数取值相同，都是权限表达式（也可使用自定义表达式） @PostAuthorize 表示方法或类执行结束后判断权限，很少被使用到 12// 在启动类或配置类添加注解@EnableGlobalMethodSecurity(prePostEnabled = true) 12345@PreAuthorize(&quot;hasRole('test')&quot;) // 加不加前缀都可@RequestMapping(&quot;/toMain&quot;)public String toMain(){ return &quot;redirect:/main.html&quot;;} 10. RememberMe 功能实现 用户只需要在登录时添加 remember-me 复选框，取值为 true。SpringSecurity 会自动把用户信息存储到数据源中，以后就可以不登录进行访问 SpringSecurity 实现 RememberMe 功能时底层依赖 spring-jdbc pom.xml 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 包含 spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; application.properties 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root SecurityConfig.java 123456789101112131415161718192021222324@Autowiredprivate DataSource dataSource;@Autowiredprivate UserDetailsServiceImpl userDetailsService;http.rememberMe() // 设置表单参数名 .rememberMeParameter(&quot;remember-me&quot;) // 存储时间，默认两周，此处为60s .tokenValiditySeconds(60) // 登录逻辑交给哪个对象（必须配置） .userDetailsService(userDetailsService) // 存储token的数据源 .tokenRepository(persistentTokenRepository());@Beanpublic PersistentTokenRepository persistentTokenRepository(){ JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); // 设置数据源 jdbcTokenRepository.setDataSource(dataSource); // 自动建表：第一次启动时开启，第二次启动时关闭 jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository;} static/login.html 1记住我：&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot; /&gt; 11. 在 Thymeleaf 中使用 SpringSecurity SpringSecurity 可以在一些视图技术中进行控制显示效果，如：JSP、Thymeleaf。在非前后端分离且使用 SpringBoot 的项目中多使用 Thymeleaf 作为视图展示技术 Thymeleaf 对 SpringSecurity 的支持都放在 thymeleaf-extras-springsecurity&lt;X&gt; 中，目前最新版本为 5 Thymeleaf 主要能展示的是 UsernamePasswordAuthenticationToken 及其父类中的字段 pom.xml 12345678&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; templates/demo.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;!-- 引入 thymeleaf 命名空间和 security 命名空间 --&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录账号:&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br/&gt;登录账号:&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br/&gt;凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br/&gt;权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br/&gt;客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br/&gt;sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br/&gt;通过权限判断：&lt;button sec:authorize=&quot;hasAuthority('insert')&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority('delete')&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority('update')&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority('select')&quot;&gt;查看&lt;/button&gt;&lt;br/&gt;通过角色判断：&lt;button sec:authorize=&quot;hasRole('test')&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole('test')&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole('test')&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole('test')&quot;&gt;查看&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; LoginController.java 1234@RequestMapping(&quot;/demo&quot;)public String demo() { return &quot;demo&quot;;} 12. 退出登录 只需要发送 /logout 请求即可退出，退出后默认跳转到 /login?logout static/main.html 1&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt; SecurityConfig.java 12345http.logout() // 自定义退出请求 .logoutUrl(&quot;/logout&quot;) // 自定义退出成功后跳转的页面 .logoutSuccessUrl(&quot;/login.html&quot;); 源码解析1234567891011121314151617181920212223242526272829303132// 退出拦截器private LogoutFilter createLogoutFilter(H http) { logoutHandlers.add(contextLogoutHandler); logoutHandlers.add(postProcess(new LogoutSuccessEventPublishingLogoutHandler())); LogoutHandler[] handlers = logoutHandlers.toArray(new LogoutHandler[0]); LogoutFilter result = new LogoutFilter(getLogoutSuccessHandler(), handlers); result.setLogoutRequestMatcher(getLogoutRequestMatcher(http)); result = postProcess(result); return result;}public class SecurityContextLogoutHandler implements LogoutHandler { ... public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { Assert.notNull(request, &quot;HttpServletRequest required&quot;); // 销毁 HttpSession 对象 if (invalidateHttpSession) { HttpSession session = request.getSession(false); if (session != null) { logger.debug(&quot;Invalidating session: &quot; + session.getId()); session.invalidate(); } } // 清除 Authentication 认证对象 if (clearAuthentication) { SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(null); } // 清除整个上下文 SecurityContextHolder.clearContext(); }} 123456789101112131415161718// 退出调用的是LogoutSuccessHandlerprivate LogoutSuccessHandler createDefaultSuccessHandler() { SimpleUrlLogoutSuccessHandler urlLogoutHandler = new SimpleUrlLogoutSuccessHandler(); urlLogoutHandler.setDefaultTargetUrl(logoutSuccessUrl); if (defaultLogoutSuccessHandlerMappings.isEmpty()) { return urlLogoutHandler; } DelegatingLogoutSuccessHandler successHandler = new DelegatingLogoutSuccessHandler(defaultLogoutSuccessHandlerMappings); successHandler.setDefaultLogoutSuccessHandler(urlLogoutHandler); return successHandler;}public class SimpleUrlLogoutSuccessHandler extends AbstractAuthenticationTargetUrlRequestHandler implements LogoutSuccessHandler { public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { // sendRedirect 重定向到目标 URL super.handle(request, response, authentication); }} 13. CSRF CSRF（Cross-site request forgery, 跨站请求伪造）也被称为 OneClick Attack 或者 Session Riding：通过伪造用户请求访问受信任站点的非法请求访问 客户端与服务器进行交互时，由于 http 协议本身是无状态协议，所以引入了 cookie 进行记录客户端身份。在 cookie 中会存放 session id 用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情 从 SpringSecurity 4 开始 CSRF 防护默认开启。默认会拦截请求，进行 CSRF 处理。CSRF 为了保证不是其他第三方网站访问，要求访问时携带参数名为 _csrf 值为 token（在服务端产生）的内容，如果 token 和服务端的 token 匹配成功，则正常访问 templates/login.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; th:value=&quot;${_csrf.token}&quot; name=&quot;_csrf&quot; th:if=&quot;${_csrf}&quot;/&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 14. CORS 跨域：浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的（只要网络协议、ip 地址、端口中任何一个不相同就是跨域请求） 由于资源都受到 SpringSecurity 的保护，因此既需要在 SpringBoot 中配置跨域，也需要在 SpringSecurity 中开启跨域","link":"/Java/SpringSecurity/springsecurity-config.html"},{"title":"SpringSecurity 前后端分离项目实战","text":"本文讲述了安全访问框架 SpringSecurity 的基本使用、自定义认证配置、授权流程以及框架的底层原理 一、概述1. 安全框架 安全框架：解决系统安全问题的框架。如果没有安全框架，我们需要手动处理每个资源的访问控制，非常麻烦。使用安全框架，我们可以通过配置的方式实现对资源的访问限制 SpringSecurity：Spring 家族的一员。是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了Spring IoC（Inversion of Control, 控制反转），DI（Dependency Injection, 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作 Apache Shiro：一个功能强大且易于使用的 Java 安全框架，提供了认证、授权、加密和会话管理 SpringSecurity 与 Shiro 对比： SpringSecurity 提供了更丰富的功能，社区资源也比 Shiro 丰富 一般来说中大型的项目都是使用 SpringSecurity 来做安全框架。小项目用 Shiro 的比较多，因为相比于 SpringSecurity，Shiro 的上手更加的简单 2. 简介 SpringSecurity 是一个高度自定义的安全框架。利用 Spring IOC、DI 和 AOP 功能，为系统提供了声明式安全访问控制功能，减少了为系统安全而编写大量重复代码的工作 使用 SpringSecruity 的原因有很多，但大部分都是发现了 javaEE 的 Servlet 规范或 EJB 规范中的安全功能缺乏典型企业应用场景。同时认识到他们在 WAR 或 EAR 级别无法移植。因此如果你更换服务器环境，还有大量工作去重新配置你的应用程序。使用 SpringSecurity 解决了这些问题，也为你提供许多其他有用的、可定制的安全功能 应用程序的两个主要区域是“认证”和“授权”。这两点也是 SpringSecurity 重要核心功能 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 授权：指确定一个主体是否允许在你的应用程序执行一个动作的过程，通俗点讲就是系统判断用户是否有权限去做某些事情 3. 历史 SpringSecurity 以“The Acegi Secutity System for Spring”的名字始于 2003 年年底。其前身为 acegi 项目 起因是 Spring 开发者邮件列表中的一个问题，有人提问是否考虑提供一个基于 Spring 的安全实现。限制于时间问题，开发出了一个简单的安全实现，但是并没有深入研究。几周后，Spring 社区中其他成员同样询问了安全问题，代码便提供给了这些人 2004 年 1 月份已经有 20 人左右使用这个项目。随着更多人的加入，在 2004 年 3 月左右在 sourceforge 中建立了一个项目 在最开始并没有认证模块，所有的认证功能都是依赖容器完成的，而 acegi 则注重授权。但是随着更多人的使用，基于容器的认证就显现出了不足。acegi 中也加入了认证功能。大约 1 年后 acegi 成为 Spring 子项目。在 2006 年 5 月发布了 acegi 1.0.0 版本。2007 年底 acegi 更名为 SpringSecurity 4. HelloWorld 新建一个 Maven 工程 添加依赖： 123456789101112131415161718192021&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 启动类、TestController 略 访问测试接口，发现页面跳转到一个 Spring Security 的默认登陆页面（默认用户名 user，密码在控制台），登陆后即可访问到测试接口 现象说明：①Spring Security 已生效；②默认所有的访问都需要登录后才能生效 二、认证1. 自定义 UserDetailsService 创建一个类实现 UserDetailsService 接口，重写其中的方法，通过用户名从数据库中查询用户信息，返回 UserDetails 类型 MyUserDetailsService.java 123456789101112131415161718@Service@RequiredArgsConstructorpublic class MyUserDetailsService implements UserDetailsService { private final SysUserService sysUserService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { SysUser sysUser = sysUserService.getByUsername(username); if(ObjectUtil.isNull(sysUser)) { throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;); } LoginUser loginUser = BeanUtil.copyProperties(sysUser, LoginUser.class); // TODO AuthorityList loginUser.setAuths(Arrays.asList(&quot;system:user:list&quot;, &quot;system:user:test&quot;)); return loginUser; }} LoginUser.java 12345678910111213141516171819202122232425262728293031323334353637public class LoginUser extends SysUser implements UserDetails { @Getter @Setter private List&lt;String&gt; auths; @JsonIgnore private Collection&lt;? extends GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { if(ObjectUtil.isNull(authorities)) { authorities = AuthorityUtils.createAuthorityList(auths.toArray(new String[0])); } return authorities; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; }} 2. 密码加密存储 默认使用的 PasswordEncoder 要求数据库中的密码格式为 {xx}password。它会根据 xx 去判断密码的加密方式（如 noop 表示明文存储） BCryptPasswordEncoder是 SpringSecurity 官方推荐的密码解析器，是对 bcrypt 强散列方法的具体实现，是基于 Hash 算法实现的单向加密，可以通过 strength 控制加密强度，默认 10 只需要把 BCryptPasswordEncoder 对象注入 Spring 容器中，SpringSecurity 就会使用该 PasswordEncoder 来进行密码校验 12345678@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); }} 3. 自定义登录逻辑 在接口中我们通过 AuthenticationManager 的 authenticate 方法来进行用户认证，所以需要在 SecurityConfig 中配置把 AuthenticationManager 注入容器 认证成功后要生成一个 token，放入响应中返回，同时把用户信息存入 redis 放行登录接口 LoginController.java 123456789101112@RestController@RequiredArgsConstructorpublic class LoginController { private final LoginService loginService; @PostMapping(&quot;/login&quot;) private R&lt;Map&lt;String, Object&gt;&gt; login(@RequestBody LoginForm loginForm) { return R.ok(loginService.login(loginForm.getUsername(), loginForm.getPassword())); }} LoginServiceImpl.java 12345678910111213141516171819202122@Service@RequiredArgsConstructorpublic class LoginServiceImpl implements LoginService { private final AuthenticationManager authenticationManager; private final RedisUtil redisUtil; @Override public Map&lt;String, Object&gt; login(String username, String password) { UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, password); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(ObjectUtil.isNull(authenticate)) { throw new RuntimeException(&quot;登陆失败&quot;); } LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String token = IdUtil.simpleUUID(); redisUtil.setCacheObject(Constants.REDIS_TOKEN_PREFIX + token, loginUser, Constants.TOKEN_EXPIRE); return MapUtil.of(&quot;token&quot;, token); }} SecurityConfig.java 1234567891011121314151617181920212223242526272829303132@Configuration@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter { private final AuthenticationTokenFilter authenticationTokenFilter; private final MyAuthenticationEntryPoint authenticationEntryPoint; private final MyAccessDeniedHandler accessDeniedHandler; @Override protected void configure(HttpSecurity http) throws Exception { // 关闭csrf，允许跨域 http.csrf().disable().cors() // 不通过Session获取SecurityContext .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and().authorizeRequests() .antMatchers(&quot;/login&quot;).anonymous() // 放行登录接口 .anyRequest().authenticated(); // 其他请求需授权访问 } @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); }} 4. 自定义认证逻辑 自定义一个过滤器，这个过滤器会去获取请求头中的 token 在 redis 中获取对应的 LoginUser 对象 封装 Authentication 对象存入 SecurityContextHolder AuthenticationTokenFilter.java 123456789101112131415161718192021222324252627@Component@RequiredArgsConstructorpublic class AuthenticationTokenFilter extends OncePerRequestFilter { private final RedisUtil redisUtil; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String token = request.getHeader(Constants.TOKEN_HEADER); if(StrUtil.isEmpty(token)) { filterChain.doFilter(request, response); return; } token = StrUtil.removePrefix(token, Constants.TOKEN_PREFIX); Object loginUserObj = redisUtil.getCacheObject(Constants.REDIS_TOKEN_PREFIX + token); if(ObjectUtil.isNull(loginUserObj)) { throw new UsernameNotFoundException(&quot;请重新登录&quot;); } redisUtil.expire(Constants.REDIS_TOKEN_PREFIX + token, Constants.TOKEN_EXPIRE); LoginUser loginUser = (LoginUser) redisUtil.getCacheObject(Constants.REDIS_TOKEN_PREFIX + token); UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser.getUsername(), null, loginUser.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authenticationToken); filterChain.doFilter(request, response); }} SecurityConfig.java 1http.addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); 5. 自定义退出逻辑 删除 redis 中对应的数据即可 LoginController.java 123456789101112@RestController@RequiredArgsConstructorpublic class LoginController { private final LoginService loginService; @GetMapping(&quot;/logout&quot;) private R&lt;?&gt; logout() { loginService.logout(); return R.ok(); }} LoginServiceImpl.java 1234567891011@Service@RequiredArgsConstructorpublic class LoginServiceImpl implements LoginService { private final RedisUtil redisUtil; @Override public void logout() { redisUtil.deleteObject(Constants.REDIS_TOKEN_PREFIX + SecurityUtil.currentToken()); }} 三、授权 只需要把当前登录用户的权限信息存入 Authentication，然后设置资源所需要的权限即可 详细配置请参考：https://lb477.xyz/Java/SpringSecurity/springsecurity-config.html 1. 基于注解的权限控制 SpringSecurity 提供了基于注解的权限控制方案，这也是项目中主要采用的方式，但需要提前开启 SecurityConfig.java 1234@EnableGlobalMethodSecurity(prePostEnabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter { ...} TestController.java 123456789@RestControllerpublic class TestController { @RequestMapping(&quot;/test&quot;) @PreAuthorize(&quot;hasAuthority('system:user:test')&quot;) // 字符串表达式，若其结果为 true，就可以访问 public String test(){ return &quot;test&quot;; }} 四、原理1. 整体登录流程（前后端分离项目） 2. 完整流程概述 SpringSecurity 底层主要维护了一个过滤器链，内部包含了提供各种功能的过滤器 UsernamePasswordAuthenticationFilter：负责对登录请求进行用户认证 ExceptionTranslationFilter：负责处理过滤器链中抛出的异常 FilterSecurityInterceptor：负责校验并授予权限 3. 认证流程详解 Authentication：表示当前访问系统的用户，封装了用户相关信息 AuthenticationManager：定义了认证 Authentication 的方法 UserDetailsService：加载用户特定数据的核心接口 UserDetails：提供核心用户信息。通过 UserDetailsService 根据用户名获取处理的用户信息要封装成 UserDetails 对象返回，然后将这些信息封装到 Authentication 对象中 4. 授权流程详解 SpringSecurity 会使用默认的 FilterSecurityInterceptor 来进行权限校验 在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的 Authentication，然后获取其中的权限信息，并判断当前用户是否拥有访问当前资源所需的权限 5. 异常处理流程详解 如果在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到，内部判断是认证失败还是授权失败出现的异常 如果是认证过程中出现的异常会被封装成 AuthenticationException 然后调用 AuthenticationEntryPoint 对象的方法去进行异常处理 如果是授权过程中出现的异常会被封装成 AccessDeniedException 然后调用 AccessDeniedHandler 对象的方法去进行异常处理 如果需要自定义异常处理，只需要实现相关接口并配置给 SpringSecurity 即可","link":"/Java/SpringSecurity/springsecurity.html"},{"title":"Kafka 入门","text":"文章对 Kafka 进行了总体概述，并且介绍了 Kafka 集群搭建流程以及 Kafka 命令行的基本操作 一、概述1. Kafka 定义 Kafka 是一个分布式的基于发布/订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域 Kafka 是一个开源的分布式事件流平台（Event Streaming Platform），被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用 使用案例： 网站在前端埋点记录用户操作行为，发送到日志服务器 可通过 Flume 时刻监控日志变化，发送到 Hadoop 等大数据平台进行数据分析 Hadoop 正常读写速度受硬盘影响，约 100M/s。平常 Flume 采集速度小于 100M/s，但在特定场景，其速度会大于 200M/s。为避免造成阻塞，在中间引入 Kafka 集群作为缓冲 2. 消息队列 目前企业中比较常见的消息队列产品主要有 Kafka、ActiveMQ、RabbitMQ、RocketMQ 等 在大数据场景主要采用 Kafka 作为消息队列。在 JavaEE 开发中主要采用 ActiveMQ、RabbitMQ、RocketMQ 等 (1) 传统消息队列的应用场景 缓存/消峰：控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况（如双十一秒杀） 解耦：允许独立的扩展或修改队列两端的处理过程，只要确保它们遵守同样的接口约束（如厂家、超市和顾客） 异步通信：允许用户把一个消息放入队列，但并不立即处理它，而是在需要的时候再去处理（如登录后发送短信通知） (2) 消息队列的两种模式 点对点模式：消费者主动拉取数据，消息收到后清除消息（一对一） 发布/订阅模式：可以有多个 topic 主题，消费者消费数据之后，不删除数据，且每个消费者相互独立，都可以消费到数据 消息的发布者不会将消息直接发送给特定的订阅者，而是将发布的消息分为不同的类别，订阅者只接收感兴趣的消息 3. Kafka 基础架构 Producer：消息生产者，向 Kafka Broker 发消息的客户端 Consumer：消息消费者，向 Kafka Broker 取消息的客户端 Consumer Group（CG）：消费者组，由多个 consumer 组成 Broker：一台 Kafka 服务器就是一个 Broker Topic：可以理解为一个队列 Partition：为了实现扩展性，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列，可以分布在不同的 Broker 上 Replica：副本。一个 topic 的每个 partition 都有若干个副本，一个 Leader 和若干个 Follower Leader：主副本，生产者、消费者只针对 Leader 副本操作 Follower：从副本，实时从 Leader 同步数据，当 Leader 发生故障时，某个 Follower 会成为新的 Leader 二、 集群部署1. 集群规划 hadoop100 hadoop101 hadoop102 ZK、Kafka ZK、Kafka ZK、Kafka 2. ZooKeeper 集群部署 下载地址：Apache ZooKeeper 1234567891011121314151617181920212223242526## 准备资源$ cd /opt/src$ tar -zxvf apache-zookeeper-3.7.0-bin.tar.gz -C /opt/$ cd /opt$ mv apache-zookeeper-3.7.0-bin/ zookeeper$ cd zookeeper## 配置ZooKeeper$ mv conf/zoo_sample.cfg conf/zoo.cfg$ vim conf/zoo.cfgdataDir=/opt/zookeeper/dataserver.0=hadoop100:2888:3888server.1=hadoop101:2888:3888server.2=hadoop102:2888:3888$ mkdir data$ echo 0 &gt; data/myid # 0, 1, 2## 配置ZooKeeper环境变量$ vim /etc/profile.d/my.shexport ZOOKEEPER_HOME=/opt/zookeeperexport PATH=$PATH:$ZOOKEEPER_HOME/bin$ source /etc/profile## 集群分发$ xsync /opt/zookeeper$ xsync /etc/profile.d/my.sh 集群脚本：/usr/local/bin/zk.sh 12345678910111213141516171819202122232425262728#!/bin/bashcase $1 in&quot;start&quot;){ for i in hadoop100 hadoop101 hadoop102 do echo ------------- zookeeper $i 启动 ------------ ssh $i &quot;/opt/zookeeper/bin/zkServer.sh start&quot; done};;&quot;stop&quot;){ for i in hadoop100 hadoop101 hadoop102 do echo ------------- zookeeper $i 停止 ------------ ssh $i &quot;/opt/zookeeper/bin/zkServer.sh stop&quot; done};;&quot;status&quot;){ for i in hadoop100 hadoop101 hadoop102 do echo ------------- zookeeper $i 状态 ------------ ssh $i &quot;/opt/zookeeper/bin/zkServer.sh status&quot; done};;esac 3. Kafka 集群部署 下载地址：Apache Kafka 12345678910111213141516171819202122## 准备资源$ cd /opt/src$ tar -zxvf kafka_2.12-3.0.0.tgz -C /opt/$ cd /opt$ mv kafka_2.12-3.0.0/ kafka$ cd kafka## 配置Kafka$ vim config/server.propertiesbroker.id=0 # 0, 1, 2log.dirs=/opt/kafka/datazookeeper.connect=hadoop100:2181,hadoop101:2181,hadoop102:2181/kafka## 配置Kafka环境变量$ vim /etc/profile.d/my.shexport KAFKA_HOME=/opt/kafkaexport PATH=$PATH:$KAFKA_HOME/bin$ source /etc/profile## 集群分发$ xsync /opt/kafka$ xsync /etc/profile.d/my.sh 集群脚本：/usr/local/bin/kf.sh 1234567891011121314151617181920#!/bin/bashcase $1 in&quot;start&quot;){ for i in hadoop100 hadoop101 hadoop102 do echo ------------- kafka $i 启动 ------------ ssh $i &quot;/opt/kafka/bin/kafka-server-start.sh -daemon /opt/kafka/config/server.properties&quot; done};;&quot;stop&quot;){ for i in hadoop100 hadoop101 hadoop102 do echo ------------- kafka $i 停止 ------------ ssh $i &quot;/opt/kafka/bin/kafka-server-stop.sh&quot; done};;esac 4. 启动1234# 启动ZooKeeper集群$ zk.sh start# 启动Kafka集群$ kf.sh start 先停止 Kafka，等待其所有节点进程停止后，再停止 ZooKeeper：Kafka 将一些信息存储到了 ZooKeeper，停止前需要先和 ZooKeeper 通信 三、Kafka 命令行操作1. 主题命令行操作123456789101112131415161718192021# 查看操作主题命令参数$ bin/kafka-topics.sh# 查看当前服务器中的所有topic$ bin/kafka-topics.sh --bootstrap-server hadoop100:9092,hadoop101:9092 --list# 创建topic（1个分区，3个副本，名为test）$ bin/kafka-topics.sh --bootstrap-server hadoop100:9092 --create --partitions 1 --replication-factor 3 --topic test# 查看topic详情$ bin/kafka-topics.sh --bootstrap-server hadoop100:9092 --describe --topic testTopic: test TopicId: D7jWqskZSf-F-MC39chP5A PartitionCount: 1 ReplicationFactor: 3 Configs: segment.bytes=1073741824 Topic: test Partition: 0 Leader: 2 Replicas: 2,1,0 Isr: 2,1,0# 修改分区数（只能增加，不能减少）$ bin/kafka-topics.sh --bootstrap-server hadoop100:9092 --alter --topic test --partitions 3# 修改副本数（不能通过命令行方式修改）# 再次查看详情$ bin/kafka-topics.sh --bootstrap-server hadoop100:9092 --describe --topic testTopic: test TopicId: D7jWqskZSf-F-MC39chP5A PartitionCount: 3 ReplicationFactor: 3 Configs: segment.bytes=1073741824 Topic: test Partition: 0 Leader: 2 Replicas: 2,1,0 Isr: 2,1,0 Topic: test Partition: 1 Leader: 0 Replicas: 0,1,2 Isr: 0,1,2 Topic: test Partition: 2 Leader: 1 Replicas: 1,2,0 Isr: 1,2,0# 删除topic$ bin/kafka-topics.sh --bootstrap-server hadoop100:9092 --delete --topic test 核心参数 参数 描述 --bootstrap-server &lt;String: server to connect to&gt; 连接的 Kafka Broker 的主机名称和端口号 --topic &lt;String: topic&gt; 操作的 topic 名称 --create 创建主题 --delete 删除主题 --alter 修改主题 --list 查看所有主题 --describe 查看主题详细描述 --partitions &lt;Integer: # of partitions&gt; 设置分区数 --replication-factor &lt;Integer: replication factor&gt; 设置分区副本 --config &lt;String: name=value&gt; 更新系统默认的配置 2. 生产者命令行操作12345# 查看操作生产者命令参数$ bin/kafka-console-producer.sh# 发送消息$ bin/kafka-console-producer.sh --bootstrap-server hadoop100:9092 --topic test&gt;hello 核心参数 参数 描述 --bootstrap-server &lt;String: server to connect to&gt; 连接的 Kafka Broker 的主机名称和端口号 --topic &lt;String: topic&gt; 操作的 topic 名称 3. 消费者命令行操作123456# 查看操作消费者命令参数$ bin/kafka-console-consumer.sh# 消费topic中的数据$ bin/kafka-console-consumer.sh --bootstrap-server hadoop100:9092 --topic test# 把主题中所有的数据都读取出来（包括历史数据）$ bin/kafka-console-consumer.sh --bootstrap-server hadoop100:9092 --from-beginning --topic test 核心参数 参数 描述 --bootstrap-server &lt;String: server to connect to&gt; 连接的 Kafka Broker 的主机名称和端口号 --topic &lt;String: topic&gt; 操作的 topic 名称 --from-beginning 从头开始消费 --group &lt;String: consumer group id&gt; 指定消费者组名称 四、其他1. Kafka 配置文件server.properties 12345678910111213141516171819202122232425262728# broker的全局唯一编号，不能重复，只能是数字broker.id=0# 处理网络请求的线程数量num.network.threads=3# 处理磁盘IO的线程数量num.io.threads=8# 发送套接字的缓冲区大小socket.send.buffer.bytes=102400# 接收套接字的缓冲区大小socket.receive.buffer.bytes=102400# 请求套接字的缓冲区大小socket.request.max.bytes=104857600# kafka运行日志/数据存放的路径，无需提前创建，可以配置多个磁盘路径，用“,”分割log.dirs=/opt/kafka/data# topic在当前broker上的分区个数num.partitions=1# 恢复和清理data下数据的线程数量num.recovery.threads.per.data.dir=1# 每个topic创建时的副本数offsets.topic.replication.factor=1# segment文件保留的最长时间，超时将被删除log.retention.hours=168# 每个segment文件的大小，默认最大1Glog.segment.bytes=1073741824# 检查过期数据的时间，默认5分钟检查一次是否数据过期log.retention.check.interval.ms=300000# 配置连接ZooKeeper集群地址（在ZK根目录下创建“/kafka”，方便管理）zookeeper.connect=hadoop100:2181,hadoop101:2181,hadoop102:2181/kafka","link":"/BigData/Kafka/kafka-helloworld.html"},{"title":"Kafka 生产者详解","text":"文章对 Kafka 生产者发送原理进行了概述，给出了 Kafka Java API 的一些基本操作，介绍了生产者分区的原理，还讲述了如何提高生产者吞吐量、幂等性原理及生产者事务处理流程、数据重复问题、数据有序等 一、生产者消息发送流程1. 发送原理 Interceptors：拦截器，对数据进行处理（可选，一般不用） Serializer：序列化器，对数据序列化（Java 序列化器比较重，有效数据占比低） Partitioner：分区器，对数据进行分区处理 分区过程在内存中完成，RecordAccumulator 是一个队列容器类，大小默认为 32M，一批次大小默认为 16K 双端队列，一边从内存池申请内存，一边释放内存 Sender：将缓冲队列中的数据发送到 Kafka 集群 Sender 拉取数据条件： batch.size：批次数据量达到后发送，默认 16K linger.ms：批次数据量未达到 batch.size，经过 linger.ms 时间后发送，默认 0ms，表示直接发送 Sender 发送流程： 分区数据要发往不同的 Kafka 集群节点，以节点 broker id 为 key，需要发送的数据为 value，形成一个 request 请求，放在 InFlightRequests 中 若请求没有及时应答，仍可以继续发送请求，但每个 Broker 节点最多缓存 5 个请求 发送到 Kafka 集群之后，集群通过副本同步机制创建副本 Selector：打通发送数据到 Kafka 集群的链路 应答机制： Kafka 应答级别 acks 0：生产者发送过来的数据，不需要等数据落盘应答 1：生产者发送过来的数据，Leader 收到数据后应答 -1/all：生产者发送过来的数据，Leader 和 ISR 队列里面的所有节点收齐数据后应答 若应答成功，生产者清理请求，并且清理对应分区的数据 若应答失败，则请求重试，次数为 retries，默认为 int 的最大值，直到重试成功 2. 生产者重要参数 参数名称 描述 bootstrap.servers 生产者连接集群所需的 broker 地址清单。多个地址用逗号隔开 key.serializer 和 value.serializer 指定发送消息的 key 和 value 的序列化类型。写全类名 buffer.memory RecordAccumulator 缓冲区总大小，默认 32M batch.size 缓冲区一批数据的最大值，默认 16K。适当增加该值，可以提高吞吐量，但过大会导致延迟增加 linger.ms 如果数据迟迟未达到 batch.size，sender 等待 linger.time 后发送数据。默认 0ms，表示无延迟。建议 5-100ms acks 见上文，默认 -1 max.in.flight.requests.per.connection 允许最多没有返回 ack 的次数，默认为 5，开启幂等性要保证该值是 1-5 retries 消息应答失败后的重试次数，默认 int 最大值 retry.backoff.ms 两次重试之间的时间间隔，默认 100ms enable.idempotence 是否开启幂等性，默认 true compression.type 生产者发送数据的压缩方式，默认是 none，即不压缩。可设置为 none、gzip、snappy、lz4 或 zstd 二、发送 API1. 环境准备 搭建 Maven 工程 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 关键 API： 2. 异步发送 异步：外部数据无差别到缓冲队列 (1) 普通异步发送12345678910111213Properties properties = new Properties();properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;hadoop100:9092,hadoop101:9092&quot;);properties.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());properties.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties);for (int i = 0; i &lt; 5; i++) { // 发送数据 producer.send(new ProducerRecord&lt;String, String&gt;(&quot;test&quot;, &quot;hello&quot; + i));}producer.close(); (2) 回调异步发送 回调函数会在 producer 收到 ack 时调用，为异步调用 1234567891011121314151617for (int i = 0; i &lt; 5; i++) { producer.send(new ProducerRecord&lt;String, String&gt;(&quot;test&quot;, &quot;hello&quot; + i), new Callback() { public void onCompletion(RecordMetadata metadata, Exception exception) { if (exception == null) { // 回调成功（发送失败会自动重试，无需在回调中手动重试） System.out.println(&quot;主题：&quot; + metadata.topic() + &quot;，分区：&quot; + metadata.partition()); } else { exception.printStackTrace(); } } }); Thread.sleep(2);}// 主题：test，分区：2// 主题：test，分区：2// 主题：test，分区：2// 主题：test，分区：1// 主题：test，分区：1 3. 同步发送 同步：外部数据分批次到缓冲队列，应答后再进下一批次 12345678910111213141516for (int i = 0; i &lt; 5; i++) { producer.send(new ProducerRecord&lt;String, String&gt;(&quot;test&quot;, &quot;hello&quot; + i), new Callback() { public void onCompletion(RecordMetadata metadata, Exception exception) { if (exception == null) { // 回调成功（发送失败会自动重试，无需在回调中手动重试） System.out.println(&quot;主题：&quot; + metadata.topic() + &quot;，分区：&quot; + metadata.partition()); } else { exception.printStackTrace(); } } }).get();}// 主题：test，分区：0// 主题：test，分区：2// 主题：test，分区：0// 主题：test，分区：1// 主题：test，分区：0 三、生产者分区1. 分区器作用 便于合理使用存储资源：可以把海量的数据按照分区切割成一块一块数据存储在多台 Broker 上。合理控制分区的任务，可以实现负载均衡的效果（如根据服务器存储能力控制分区） 提高并行度：生产者可以以分区为单位发送数据，消费者可以以分区为单位消费数据（多线程） 2. 分区策略 默认分区器：DefaultPartitioner If a partition is specified in the record, use it If no partition is specified but a key is present, choose a partition based on a hash of the key（如以表名为 key） If no partition or key is present, choose the sticky partition that changes when the batch is full（随机选一个分区，待该分区 batch 已满或已完成，再随机选另一个分区） 3. 自定义分区器 实现 Partitioner 接口 使用该分区器： 12// 此时若指定partition，还按指定的，否则按该分区器properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class.getName()); 四、生产经验1. 提高吞吐量12345678// batch.size：批次大小，默认 16Kproperties.put(ProducerConfig.BATCH_SIZE_CONFIG, 32 * 1024);// linger.ms：等待时间，默认 0properties.put(ProducerConfig.LINGER_MS_CONFIG, 100);// compression.type：压缩类型，默认 none，可选 gzip、snappy、lz4、zstdproperties.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, &quot;snappy&quot;);// buffer.memory：缓冲区大小，默认 32Mproperties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 64 * 1024 * 1024); 2. 数据可靠性 ack 为 0 时，生产者发送的数据无需 Leader 落盘应答。若 Leader 宕机时未落盘，则数据丢失。生产环境一般不用 ack 为 1 时，生产者发送的数据 Leader 落盘后应答。 若 Leader 落盘应答后宕机，且尚未同步副本，则数据丢失。一般用于日志传输 ack 为 -1 时，生产者发送的数据 Leader 和 ISR 队列的节点落盘后应答。一般用于可靠性要求高的场景，如金钱交易 如果分区副本设为 1 个，或者 ISR 里应答的最小副本数量（min.insync.replicas，默认 1）设为 1 个，此时相当于 ack 为 1 数据完全可靠条件：ack 级别为 -1，分区副本数大于 1，ISR 里应答的最小副本数大于 1 ISR 队列 Leader 维护了一个动态的 in-sync replica set（ISR）队列，表示和 Leader 保持同步的 Follower + Leader 集合（如 Leader: 0; ISR: 0,1,2） 如果 Follower 一段时间（replica.lag.time.max.ms，默认 30s）未向 Leader 发送通信请求或同步数据，则该 Follower 会从 ISR 队列中移除 1234// acks：应答策略，默认 -1properties.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);// retries：重试次数，默认 int 最大值（2147483647）properties.put(ProducerConfig.RETRIES_CONFIG, 3); 3. 数据去重 ack 为 -1 时，若 Leader 和 ISR 队列的节点落盘后，Leader 未应答宕机，此时新的 Leader 仍会接收到数据，会导致重复数据 Kafka 0.11 版本后，引入新特性：幂等性和事务 (1) 幂等性 幂等性：Producer 不论向 Broker 发送多少次重复数据，Broker 端都只会持久化一条，保证了不重复 重复数据的判断标准：具有 &lt;PID, Partition, SeqNumber&gt; 相同键的消息提交时，Broker 只会持久化一条 PID：Kafka 每次重启都会分配一个新的 Partition：分区号 SeqNumber：单调自增，表示每一个请求 幂等性只能保证的是在单分区单会话内不重复 开启幂等性：enable.idempotence，默认 true (2) 生产者事务 幂等性保证的是单分区单会话内不重复，若 Kafka 重启，仍可能产生重复数据 精确一次：开启幂等性 + 开启事务 + 数据完全可靠条件 事务底层依赖幂等性，开启事务必须开启幂等性 Producer 在使用事务功能前，必须先自定义一个唯一的 transactional.id。这样即使 Kafka 重启也能继续处理未完成的事务 事务协调器用于处理事务。事务在提交过程中需要将一些信息持久化到磁盘，该信息就存储在特定的主题中 事务协调器的选择：每个 Broker 节点都有事务协调器。存储事务信息的主题默认有 50 个分区，每个分区处理一部分事务。事务会选择分区 hash(transactional.id) % 50 对应的 Leader 副本所在的 Broker 节点中的事务协调器去处理 1234567891011121314properties.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, &quot;transaction_test&quot;);KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties);producer.initTransactions();producer.beginTransaction();try { for (int i = 0; i &lt; 5; i++) { producer.send(new ProducerRecord&lt;String, String&gt;(&quot;test&quot;, &quot;&quot;+i, &quot;hello&quot; + i)); } int i = 1 / 0;} catch (Exception e) { producer.abortTransaction();} finally { producer.close();} 4. 数据有序 生产者发送的数据会进行分区处理，因此消费者消费到的数据不一定是有序的 单分区内有序： Kafka 1.x 版本前，设置 max.in.flight.requests.per.connection = 1（不考虑幂等性） Kafka 1.x 版本后，若未开启幂等性，则需设置 max.in.flight.requests.per.connection = 1；若开启幂等性，其值可设置为 1~5 每个节点默认最多缓存 5 个请求，开启幂等性后，Kafka 服务端会根据请求序列号按序落盘 多分区内有序：消费者拉取每一个分区的数据，统一排序后消费","link":"/BigData/Kafka/kafka-producer.html"}],"tags":[{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"NFS","slug":"NFS","link":"/tags/NFS/"},{"name":"Win","slug":"Win","link":"/tags/Win/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Software","slug":"Software","link":"/tags/Software/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SpringSecurity","slug":"SpringSecurity","link":"/tags/SpringSecurity/"},{"name":"BigData","slug":"BigData","link":"/tags/BigData/"},{"name":"Kafka","slug":"Kafka","link":"/tags/Kafka/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Win","slug":"Win","link":"/categories/Win/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"SpringSecurity","slug":"Java/SpringSecurity","link":"/categories/Java/SpringSecurity/"},{"name":"BigData","slug":"BigData","link":"/categories/BigData/"},{"name":"Kafka","slug":"BigData/Kafka","link":"/categories/BigData/Kafka/"}]}